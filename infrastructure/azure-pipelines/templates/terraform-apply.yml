# =============================================================================
# TERRAFORM APPLY TEMPLATE
# =============================================================================
# Applies Terraform changes for an environment
# =============================================================================

parameters:
  - name: workingDirectory
    type: string
    default: '$(System.DefaultWorkingDirectory)/infrastructure/terraform'

  - name: azureServiceConnection
    type: string

  - name: environment
    type: string
    default: 'dev'

  - name: usePlanFile
    type: boolean
    default: false

  - name: additionalArgs
    type: string
    default: ''

steps:
  - ${{ if eq(parameters.usePlanFile, true) }}:
    - task: DownloadPipelineArtifact@2
      displayName: 'Download Plan Artifact'
      inputs:
        artifactName: 'terraform-plan-${{ parameters.environment }}'
        targetPath: '${{ parameters.workingDirectory }}'

  - task: AzureCLI@2
    displayName: 'Terraform Apply - ${{ parameters.environment }}'
    inputs:
      azureSubscription: '${{ parameters.azureServiceConnection }}'
      scriptType: 'bash'
      scriptLocation: 'inlineScript'
      workingDirectory: '${{ parameters.workingDirectory }}'
      addSpnToEnvironment: true
      inlineScript: |
        set -e

        echo "=========================================="
        echo "TERRAFORM APPLY - ${{ parameters.environment }}"
        echo "=========================================="
        echo "Started: $(date)"
        echo "=========================================="

        # Export ARM credentials for Terraform
        export ARM_CLIENT_ID=$servicePrincipalId
        export ARM_CLIENT_SECRET=$servicePrincipalKey
        export ARM_TENANT_ID=$tenantId
        export ARM_SUBSCRIPTION_ID=$(az account show --query id -o tsv)

        # Check for plan file
        PLAN_FILE="tfplan-${{ parameters.environment }}.out"
        if [ -f "$PLAN_FILE" ]; then
          echo "Using saved plan file: $PLAN_FILE"
          terraform apply \
            -auto-approve \
            -input=false \
            -no-color \
            ${{ parameters.additionalArgs }} \
            "$PLAN_FILE"
        else
          echo "No plan file found, running apply with tfvars"

          # Check if environment-specific tfvars exists
          TFVARS_FILE="environments/${{ parameters.environment }}.tfvars"
          if [ -f "$TFVARS_FILE" ]; then
            echo "Using tfvars file: $TFVARS_FILE"
            VAR_FILE_ARG="-var-file=$TFVARS_FILE"
          else
            echo "No tfvars file found, using default with environment variable"
            VAR_FILE_ARG="-var=environment=${{ parameters.environment }}"
          fi

          terraform apply \
            $VAR_FILE_ARG \
            -auto-approve \
            -input=false \
            -no-color \
            ${{ parameters.additionalArgs }}
        fi

        echo ""
        echo "=========================================="
        echo "APPLY COMPLETED SUCCESSFULLY"
        echo "Finished: $(date)"
        echo "=========================================="

  - task: AzureCLI@2
    displayName: 'Save Outputs to Variable Group'
    inputs:
      azureSubscription: '${{ parameters.azureServiceConnection }}'
      scriptType: 'bash'
      scriptLocation: 'inlineScript'
      workingDirectory: '${{ parameters.workingDirectory }}'
      addSpnToEnvironment: true
      inlineScript: |
        # Export ARM credentials
        export ARM_CLIENT_ID=$servicePrincipalId
        export ARM_CLIENT_SECRET=$servicePrincipalKey
        export ARM_TENANT_ID=$tenantId
        export ARM_SUBSCRIPTION_ID=$(az account show --query id -o tsv)

        echo "=========================================="
        echo "TERRAFORM OUTPUTS"
        echo "=========================================="

        # Get outputs and set as pipeline variables
        AKS_NAME=$(terraform output -raw aks_name 2>/dev/null || echo "")
        ACR_LOGIN_SERVER=$(terraform output -raw acr_login_server 2>/dev/null || echo "")
        KEYVAULT_NAME=$(terraform output -raw keyvault_name 2>/dev/null || echo "")
        KEYVAULT_URI=$(terraform output -raw keyvault_uri 2>/dev/null || echo "")
        RESOURCE_GROUP=$(terraform output -raw resource_group_name 2>/dev/null || echo "")

        echo "Resource Group: $RESOURCE_GROUP"
        echo "AKS Cluster: $AKS_NAME"
        echo "ACR Login Server: $ACR_LOGIN_SERVER"
        echo "Key Vault: $KEYVAULT_NAME"

        # Set pipeline variables for subsequent tasks
        echo "##vso[task.setvariable variable=TF_OUTPUT_AKS_NAME;isOutput=true]$AKS_NAME"
        echo "##vso[task.setvariable variable=TF_OUTPUT_ACR_LOGIN_SERVER;isOutput=true]$ACR_LOGIN_SERVER"
        echo "##vso[task.setvariable variable=TF_OUTPUT_KEYVAULT_NAME;isOutput=true]$KEYVAULT_NAME"
        echo "##vso[task.setvariable variable=TF_OUTPUT_KEYVAULT_URI;isOutput=true]$KEYVAULT_URI"
        echo "##vso[task.setvariable variable=TF_OUTPUT_RESOURCE_GROUP;isOutput=true]$RESOURCE_GROUP"
    name: outputs
    continueOnError: true

  - task: AzureCLI@2
    displayName: 'Update AKS Credentials (if exists)'
    inputs:
      azureSubscription: '${{ parameters.azureServiceConnection }}'
      scriptType: 'bash'
      scriptLocation: 'inlineScript'
      workingDirectory: '${{ parameters.workingDirectory }}'
      addSpnToEnvironment: true
      inlineScript: |
        # Export ARM credentials
        export ARM_CLIENT_ID=$servicePrincipalId
        export ARM_CLIENT_SECRET=$servicePrincipalKey
        export ARM_TENANT_ID=$tenantId
        export ARM_SUBSCRIPTION_ID=$(az account show --query id -o tsv)

        AKS_NAME=$(terraform output -raw aks_name 2>/dev/null || echo "")
        RESOURCE_GROUP=$(terraform output -raw resource_group_name 2>/dev/null || echo "")

        if [ -n "$AKS_NAME" ] && [ -n "$RESOURCE_GROUP" ]; then
          echo "Fetching AKS credentials..."
          az aks get-credentials \
            --resource-group "$RESOURCE_GROUP" \
            --name "$AKS_NAME" \
            --overwrite-existing \
            --admin || true

          echo "AKS cluster nodes:"
          kubectl get nodes 2>/dev/null || echo "Could not connect to cluster"
        else
          echo "AKS not deployed or outputs not available"
        fi
    continueOnError: true
